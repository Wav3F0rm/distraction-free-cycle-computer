#include <Arduino.h>
#include <U8g2lib.h>
#include <SPI.h>

#include <TinyGPS++.h>
#include <HardwareSerial.h>

#include <buttonDebounce.h>

#include <BluetoothSerial.h>

// Initialise LCD Module, using u8g2 library, and the SPI communication protocol
U8G2_ST7565_ERC12864_ALT_F_4W_SW_SPI u8g2(U8G2_R3, /*Clock:*/ 9,/*Data:*/ 10, /*CS:*/ 2, /*DC:*/ 4, /*Reset:*/ 0);

int lcdContrast = 70;

// Define Vertical Layout for Display
#define Vertical2_width 64
#define Vertical2_height 128
static unsigned char Vertical2_bits[] = {
   0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0f, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40,
   0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
   0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
   0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
   0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
   0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
   0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
   0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
   0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
   0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
   0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
   0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
   0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
   0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
   0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
   0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
   0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
   0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30,
   0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0f,
   0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40,
   0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
   0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
   0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30,
   0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0f,
   0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40,
   0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
   0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
   0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30,
   0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0f,
   0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40,
   0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
   0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
   0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30,
   0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0f,
   0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40,
   0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
   0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
   0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30,
   0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xff, 0x00, 0xfc, 0x3f, 0x00, 0xff, 0x0f,
   0x0c, 0x00, 0x03, 0x03, 0xc0, 0xc0, 0x00, 0x30, 0x02, 0x00, 0x84, 0x00, 0x00, 0x21, 0x00, 0x40, 0x02, 0x00, 0x84, 0x00, 0x00, 0x21, 0x00, 0x40,
   0x01, 0x00, 0x48, 0x00, 0x00, 0x12, 0x00, 0x80, 0x01, 0x00, 0x48, 0x00, 0x00, 0x12, 0x00, 0x80, 0x01, 0x00, 0x48, 0x00, 0x00, 0x12, 0x00, 0x80,
   0x01, 0x00, 0x48, 0x00, 0x00, 0x12, 0x00, 0x80, 0x02, 0x00, 0x84, 0x00, 0x00, 0x21, 0x00, 0x40, 0x02, 0x00, 0x84, 0x00, 0x00, 0x21, 0x00, 0x40,
   0x0c, 0x00, 0x03, 0x03, 0xc0, 0xc0, 0x00, 0x30, 0xf0, 0xff, 0x00, 0xfc, 0x3f, 0x00, 0xff, 0x0f };

// Define music symbol for music view
#define Music_width 43
#define Music_height 45
static unsigned char Music_bits[] = {
   0x00, 0x00, 0x00, 0x00, 0x80, 0x07, 0x00, 0x00, 0x00, 0x00, 0xff, 0x07,
   0x00, 0x00, 0x00, 0xfe, 0xff, 0x07, 0x00, 0x00, 0xfc, 0xff, 0xff, 0x07,
   0x00, 0xf0, 0xff, 0xff, 0xff, 0x07, 0x00, 0xfe, 0xff, 0xff, 0xff, 0x07,
   0x00, 0xfe, 0xff, 0xff, 0xff, 0x07, 0x00, 0xfe, 0xff, 0xff, 0xff, 0x07,
   0x00, 0xfe, 0xff, 0xff, 0xff, 0x07, 0x00, 0xfe, 0xff, 0xff, 0xff, 0x07,
   0x00, 0xfe, 0xff, 0x7f, 0x80, 0x07, 0x00, 0xfe, 0xff, 0x07, 0x80, 0x07,
   0x00, 0xfe, 0x1f, 0x00, 0x80, 0x07, 0x00, 0x3e, 0x00, 0x00, 0x80, 0x07,
   0x00, 0x1e, 0x00, 0x00, 0x80, 0x07, 0x00, 0x1e, 0x00, 0x00, 0x80, 0x07,
   0x00, 0x1e, 0x00, 0x00, 0x80, 0x07, 0x00, 0x1e, 0x00, 0x00, 0x80, 0x07,
   0x00, 0x1e, 0x00, 0x00, 0x80, 0x07, 0x00, 0x1e, 0x00, 0x00, 0x80, 0x07,
   0x00, 0x1e, 0x00, 0x00, 0x80, 0x07, 0x00, 0x1e, 0x00, 0x00, 0x80, 0x07,
   0x00, 0x1e, 0x00, 0x00, 0x80, 0x07, 0x00, 0x1e, 0x00, 0x00, 0x80, 0x07,
   0x00, 0x1e, 0x00, 0x00, 0x80, 0x07, 0x00, 0x1e, 0x00, 0x00, 0x80, 0x07,
   0x00, 0x1e, 0x00, 0x00, 0x80, 0x07, 0x00, 0x1e, 0x00, 0x00, 0x80, 0x07,
   0x00, 0x1e, 0x00, 0x00, 0x80, 0x07, 0x00, 0x1e, 0x00, 0x00, 0xfc, 0x07,
   0x00, 0x1e, 0x00, 0x80, 0xff, 0x07, 0x00, 0x1e, 0x00, 0xc0, 0xff, 0x07,
   0x00, 0x1e, 0x00, 0xc0, 0xff, 0x07, 0xe0, 0x1f, 0x00, 0xe0, 0xff, 0x03,
   0xf8, 0x1f, 0x00, 0xe0, 0xff, 0x03, 0xfe, 0x1f, 0x00, 0xe0, 0xff, 0x03,
   0xfe, 0x1f, 0x00, 0xe0, 0xff, 0x03, 0xff, 0x1f, 0x00, 0xe0, 0xff, 0x01,
   0xff, 0x1f, 0x00, 0xc0, 0xff, 0x00, 0xff, 0x1f, 0x00, 0xc0, 0x7f, 0x00,
   0xff, 0x1f, 0x00, 0x00, 0x1f, 0x00, 0xff, 0x0f, 0x00, 0x00, 0x00, 0x00,
   0xff, 0x07, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x07, 0x00, 0x00, 0x00, 0x00,
   0xfc, 0x01, 0x00, 0x00, 0x00, 0x00 };

// Define goose symbol for menu view
#define Goose_width 35
#define Goose_height 50
static unsigned char Goose_bits[] = {
   0xf0, 0x01, 0x00, 0x00, 0x00, 0xf8, 0x03, 0x00, 0x00, 0x00, 0xf8, 0x07,
   0x00, 0x00, 0x00, 0xf8, 0x0f, 0x00, 0x00, 0x00, 0xf8, 0x0f, 0x00, 0x00,
   0x00, 0x1c, 0x0e, 0x00, 0x00, 0x00, 0x04, 0x1c, 0x00, 0x00, 0x00, 0x02,
   0x18, 0x00, 0x00, 0x00, 0x01, 0x18, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x00,
   0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00,
   0x00, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x0f,
   0x00, 0x00, 0x00, 0x80, 0x07, 0x00, 0x00, 0x00, 0x80, 0x07, 0x00, 0x00,
   0x00, 0xc0, 0x03, 0x00, 0x00, 0x00, 0xc0, 0x01, 0x00, 0x00, 0x00, 0xe0,
   0x01, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x00,
   0x00, 0x00, 0x78, 0x00, 0x00, 0x00, 0x00, 0x78, 0x00, 0x00, 0x00, 0x00,
   0xf8, 0xff, 0x01, 0x00, 0x00, 0xfc, 0xff, 0x0f, 0x00, 0x00, 0xfc, 0xff,
   0x1f, 0x00, 0x00, 0xfc, 0xff, 0x3f, 0x00, 0x00, 0xfc, 0xff, 0xff, 0x00,
   0x00, 0xfc, 0xff, 0xff, 0xc3, 0x04, 0xf8, 0xff, 0xff, 0xcf, 0x02, 0xf8,
   0xff, 0xff, 0xff, 0x01, 0xf8, 0xff, 0xff, 0xff, 0x07, 0xf0, 0xff, 0xff,
   0xff, 0x07, 0xf0, 0xff, 0xff, 0xff, 0x00, 0xe0, 0xff, 0xff, 0xff, 0x01,
   0xc0, 0xff, 0xff, 0xff, 0x00, 0x80, 0xff, 0xff, 0x3f, 0x00, 0x00, 0xfe,
   0x7f, 0x00, 0x00, 0x00, 0x40, 0x3c, 0x00, 0x00, 0x00, 0x40, 0x38, 0x00,
   0x00, 0x00, 0x40, 0x30, 0x00, 0x00, 0x00, 0x40, 0x60, 0x00, 0x00, 0x00,
   0x40, 0x40, 0x00, 0x00, 0x00, 0x20, 0x40, 0x00, 0x00, 0x00, 0x70, 0x40,
   0x00, 0x00, 0x00, 0x1e, 0x40, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00,
   0x00, 0x00, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00 };


// Define reset symbol for the display
#define Reset_width 10
#define Reset_height 8
static unsigned char Reset_bits[] = {
   0xfe, 0x00, 0xff, 0x01, 0xc3, 0x01, 0xe3, 0x03, 0xe3, 0x03, 0xc3, 0x01,
   0xbf, 0x00, 0x7e, 0x00 };

// Define Play/Pause symbol for the display
#define PlayPause_width 10
#define PlayPause_height 8
static unsigned char PlayPause_bits[] = {
   0x5b, 0x00, 0xdb, 0x00, 0xdb, 0x01, 0xdb, 0x03, 0xdb, 0x03, 0xdb, 0x01,
   0xdb, 0x00, 0x5b, 0x00 };

// Define Menu symbol for the display
#define Menu_width 10
#define Menu_height 8
static unsigned char Menu_bits[] = {
   0xff, 0x03, 0xff, 0x03, 0x00, 0x00, 0xff, 0x03, 0xff, 0x03, 0x00, 0x00,
   0xff, 0x03, 0xff, 0x03 };

// Define SkipForward symbol for this display
#define SkipForward_width 10
#define SkipForward_height 8
static unsigned char SkipForward_bits[] = {
   0x22, 0x00, 0x66, 0x00, 0xee, 0x00, 0xfe, 0x01, 0xfe, 0x01, 0xee, 0x00,
   0x66, 0x00, 0x22, 0x00 };

// Define SkipBack symbol for the display
#define SkipBack_width 10
#define SkipBack_height 8
static unsigned char SkipBack_bits[] = {
   0x10, 0x01, 0x98, 0x01, 0xdc, 0x01, 0xfe, 0x01, 0xfe, 0x01, 0xdc, 0x01,
   0x98, 0x01, 0x10, 0x01 };

String displayLayout = "Menu";

/*
Data points to store:
  - Number of Satellites | How many satellites the GPS module is connected to
  - Speed
  - Altitude
  - Heading | Direction of travel from north, represented in degrees
  - Time
  - Distance Travelled | Approximate value taken from velocity over X time interval
  - Time since start of ride/pace timer | simple 
*/
int gpsSatellites = 0;
float gpsSpeed = 0;
int gpsHour = 0;
int gpsMinute = 0;
char gpsTime[50];

float distTravelled = 0;

unsigned int i = 0;
float totalSpeed = 0;
float averageSpeed = 0;

float gpsLastSpeed = 0;
float gpsDisplaySpeed = 0;

// helper variables to store times for speed > distance & secondSinceStart calculation
unsigned long lastMillis = 0;
unsigned long currentMillis = 0;
unsigned long startMillis = 0;

unsigned long durationSeconds = 0;
unsigned long durationMinutes = 0;
unsigned long durationHours = 0;
char durationFormatted[50];

int button1 = 36; int button1State; int lastButton1State = LOW; unsigned long lastButton1Debounce = 0;
int button2 = 37; int button2State; int lastButton2State = LOW; unsigned long lastButton2Debounce = 0;
int button3 = 38; int button3State; int lastButton3State = LOW; unsigned long lastButton3Debounce = 0;
int debounceDelay = 70;

bool togglePlayPause = 0;

int tempSensor = 39;
float temperatures[10];
float temp;
unsigned int x;

int ledR = 32;
int ledG = 33;
int ledB = 25;

int metadataType;
String songName;
String artistName;
String songDuration;

// Initialise gpsSerial using HardwareSerial.
HardwareSerial gpsSerial(1);  // Select UART1, UART0 is used for USB transfer
TinyGPSPlus gps; // Create identifier for TinyGPSPlus

//Initialise Serial Bluetooth using BluetoothSerial.
BluetoothSerial SerialBT; // Select UART2, UART0 & UART 1 are used for USB transfer

// This code will run once at the beginning of the project
void setup(void) {
  Serial.begin(115200);  // begin ESP32 Serial @ 115200 baud
  gpsSerial.begin(9600, SERIAL_8N1, 22, 21);  // begin GPS Serial @ 9600 baud (refresh rate of gps module). Use GPIO22 for RX & GPIO21 for TX
  SerialBT.begin("CycleComputer"); // begin SerialBT with the name "CycleComputer"

  u8g2.begin();
  u8g2.setContrast(lcdContrast);

  // assign RGB led pins to channels, 12 kHz PWM, 8-bit resolution
  ledcAttachPin(ledR, 1); ledcSetup(1, 12000, 8);
  ledcAttachPin(ledG, 2); ledcSetup(2, 12000, 8);
  ledcAttachPin(ledB, 3); ledcSetup(3, 12000, 8);

  pinMode(button1, INPUT);
  pinMode(button2, INPUT);
  pinMode(button3, INPUT);
}

void loop(void) {
  // feed the hungry gps object using serial input from gps module
  while(gpsSerial.available()){
    gps.encode(gpsSerial.read());
  }

  if (Serial.available()) {
    SerialBT.write(Serial.read());
  }
  /*if (SerialBT.available()) {
    Serial.write(SerialBT.read());
  }*/

  char tempCharacter;
  if (SerialBT.available()) {
    tempCharacter = char(SerialBT.read());
    }

  if (tempCharacter == '@') {
    metadataType = 0;
    songName = "";
    artistName = "";
    songDuration = "";
  }
  else if (tempCharacter == '#') {
    metadataType = 1;
  }
  else if (tempCharacter == '$') {
    metadataType = 2;
  } 
  else if (tempCharacter == '&') {
    songName += '\0';
    artistName += '\0';
    songDuration += '\0';
    Serial.println("Name: " + songName + " Artist: " + artistName + " Duration: " + songDuration);
  } else {
    if (metadataType == 0) {
      songName += tempCharacter;
    }
    else if (metadataType == 1) {
      artistName += tempCharacter;
    }
    else if (metadataType == 2) {
      songDuration += tempCharacter;
    }
  }

  bool back2Menu = false;

  int reading1 = digitalRead(button1); // Read and store state of button
  if (reading1 != lastButton1State) {lastButton1Debounce = millis();}
  if ((millis() - lastButton1Debounce) > debounceDelay) {  // If button state has changed
    button1State = reading1;
    if (button1State == HIGH) {
      back2Menu = true;
      if (displayLayout == "Telemetry") {
      // reset ride timer, distance travelled, and average speed
      distTravelled = 0;
      totalSpeed = 0; averageSpeed = 0; i = 0;
      durationHours = 0; durationMinutes = 0; durationSeconds = 0;
      startMillis = millis();
      togglePlayPause = false;
      }
      else if (displayLayout == "Music") {
      // Send Skip Previous
      SerialBT.println("Skip Previous");
      } else {
        // Menu functionality
        displayLayout = "Telemetry";
      }
    }
  }
  lastButton1State = reading1;

  int reading2 = digitalRead(button2); // Read and store state of button
  if (reading2 != lastButton2State) {lastButton2Debounce = millis();}
  if ((millis() - lastButton2Debounce) > debounceDelay) {  // If button state has changed
    button2State = reading2;
    if (button2State == HIGH) {
      if (displayLayout == "Telemetry") {
        togglePlayPause = !togglePlayPause;
        if ((togglePlayPause == true) && (totalSpeed == 0)) {
          startMillis = millis();
        }
      }
      else if (displayLayout == "Music") {
        // Send Toggle Play/Pause
        SerialBT.println("Toggle");
      } else {
        // Menu functionality
        displayLayout = "Music";
      }
    }
  }
  lastButton2State = reading2;

  int reading3 = digitalRead(button3); // Read and store state of button
  if (reading3 != lastButton3State) {lastButton3Debounce = millis();}
  if ((millis() - lastButton3Debounce) > debounceDelay) {  // If button state has changed
    button3State = reading3;
    if (button3State == HIGH) {
      if (back2Menu == true) {
          displayLayout = "Menu";
      }
      else if (displayLayout == "Telemetry") {
        // GOTO Menu
        displayLayout = "Menu";
      }
      else if (displayLayout == "Music") {
        // Send Skip Next
        SerialBT.println("Skip Next");
      } else {
        // Menu functionality
        // No Config option at this stage
      }
    }
  }
  lastButton3State = reading3;

  if (gpsSatellites >= 3) {
    setRGBLED(0, 255, 0);
  } else {
    setRGBLED(255, 0, 0);
  }

  /*
  everytime satellite value is updated (everytime GNSS module recieves a new set of NMEA sequences)
  updateTelemetry will be called, collecting new data from the GNSS module
  */
  if (gps.satellites.isUpdated()) {
    updateTelemetry();
  }

  // draw loop
  u8g2.clearBuffer();
  if (displayLayout == "Telemetry"){
    // GOTO Telemetry View
    updateTelemetryLCD();
    }
  else if (displayLayout == "Music") {
    // GOTO Music View
    updateMusicLCD();
  } else {
    // GOTO Menu
    updateMenuLCD();
  }
  u8g2.sendBuffer();
}

// Update Telemetry Screen
void updateTelemetryLCD() {
  u8g2.setFontPosBottom();
  u8g2.setFontDirection(0);

  u8g2.drawXBM(0, 0, Vertical2_width, Vertical2_height, Vertical2_bits);
  u8g2.drawXBM(5, 118, Reset_width, Reset_height, Reset_bits);
  u8g2.drawXBM(27, 118, PlayPause_width, PlayPause_height, PlayPause_bits); 
  u8g2.drawXBM(49, 118, Menu_width, Menu_height, Menu_bits);  

  u8g2.setFont(u8g2_font_luBS18_tf);
  u8g2.drawStr(2, 38, String(gpsDisplaySpeed, 1).c_str());

  u8g2.setFont(u8g2_font_t0_12_tf);
  u8g2.drawStr(38, 46, "km/h");
  
  u8g2.drawStr(5, 69, gpsTime);  // Draw time in first box
  u8g2.drawStr(5, 84, (String(distTravelled, 2) + " km").c_str());  // Draw distance travelled in second box
  u8g2.drawStr(5, 99, (String(averageSpeed, 1) + " km/h").c_str());  // Draw average speed in third box
  u8g2.drawStr(5, 114, durationFormatted);  // Draw duration of ride speed in fourth box

  u8g2.setFont(u8g2_font_5x7_tf);
  u8g2.drawStr(40, 69, (String(temp, 0) + "\xb0" + "C").c_str());  // Draw temperature in first box
}

// Update Music Screen
void updateMusicLCD() {
  u8g2.setFontPosBottom();
  u8g2.setFontDirection(0);

  // Draw layout and music symbol
  u8g2.drawXBM(0, 0, Vertical2_width, Vertical2_height, Vertical2_bits);
  u8g2.drawXBM(10, 5, Music_width, Music_height, Music_bits);

  // Draw button labels
  u8g2.drawXBM(5, 118, SkipBack_width, SkipBack_height, SkipBack_bits);
  u8g2.drawXBM(27, 118, PlayPause_width, PlayPause_height, PlayPause_bits);
  u8g2.drawXBM(49, 118, SkipForward_width, SkipForward_height, SkipForward_bits);

  // Set Font
  u8g2.setFont(u8g2_font_t0_12_tf);

  // Display time information
  u8g2.drawStr(5, 69, gpsTime);

  // Display music information
  u8g2.drawStr(4, 84, String(songName).c_str());  // Draw song name
  u8g2.drawStr(4, 99, String(artistName).c_str());  // Draw artist name
  u8g2.drawStr(5, 114, String(songDuration).c_str());  // Draw song duration

  // Display temperature information
  u8g2.setFont(u8g2_font_5x7_tf);
  u8g2.drawStr(40, 67, (String(temp, 0) + "\xb0" + "C").c_str());  // Draw temperature in first box
}

// Update Menu Screen
void updateMenuLCD() {
  u8g2.setFontPosBottom();
  u8g2.setFontDirection(0);

  // Draw layout and goose symbol <3
  u8g2.drawXBM(0, 0, Vertical2_width, Vertical2_height, Vertical2_bits);
  u8g2.drawXBM(15, 3, Goose_width, Goose_height, Goose_bits);

  // Set Font
  u8g2.setFont(u8g2_font_t0_12_tf);

  // Display time information
  u8g2.drawStr(5, 69, gpsTime);

  // Display menu options
  u8g2.drawStr(5, 84, "1. Ride");
  u8g2.drawStr(5, 99, "2. Music");
  u8g2.drawStr(5, 114, "3. Config");

 // Display button options
  u8g2.drawStr(7, 128, "1");
  u8g2.drawStr(29, 128, "2");
  u8g2.drawStr(51, 128, "3");

  // Display temperature information
  u8g2.setFont(u8g2_font_5x7_tf);
  u8g2.drawStr(40, 67, (String(temp, 0) + "\xb0" + "C").c_str());  // Draw temperature in first box
}

void updateTelemetry() {
  /*
  update telemetry gained from gps
  No. of satellites
  Speed - filtered
  Time
  Distance travelled - calculated from speed
  Average speed - calculated from distance
  Length of ride
  */  

  gpsSatellites = gps.satellites.value();
  gpsSpeed = gps.speed.kmph();

  gpsHour = gps.time.hour();
  if (gpsHour < 12){
    gpsHour += 12;
  } else if (gpsHour < 23){
    gpsHour -= 12;
  }
  gpsMinute = gps.time.minute();
  sprintf(gpsTime, "%02d:%02d", gpsHour, gpsMinute);  

  /*
  SPEED FILTERING
  if the difference in speed between current and last values is greater than 1 km/h then gpsSpeed is kept at the previous speed(Might be changed later)
  this is because rapid changes to speed could be a result of incorrect readings, so these are disregarded
  Also, sets minimum gpsSpeed to 2 km/h (Might be changed later)
  this is to prevent the inaccuracies that come with moving the gps at low speeds.
  if the reported speed is < 2 km/h gpsSpeed will be set to 0
  */
  if ((abs(gpsSpeed - gpsLastSpeed)) > 1) {
    gpsSpeed = gpsLastSpeed;
    gpsDisplaySpeed = gpsSpeed;
  } else {
    gpsDisplaySpeed = gpsSpeed;
  }
  if (gpsSpeed < 2.0) {
    gpsDisplaySpeed = 0;
  } else {
    gpsDisplaySpeed = gpsSpeed;
  }

  if (togglePlayPause == true) {
    /*
    speed -> distance calculation | every 3 seconds
    if the time between the last cycle and the current cycle is > 3000ms / 3s
    set last cycle time to current cycle time
    gpsDisplaySpeed(km/h) -> m/s * time in seconds = meters travelled since last cycle -> km travelled since last cycle
    */
    if((millis() - lastMillis) > 3000){
      i ++;
      lastMillis = millis();
      distTravelled += ((gpsDisplaySpeed/3.6)*3)/1000;

      // find average spped from sum of all total speed readings / number of readings
      totalSpeed += gpsDisplaySpeed;
      averageSpeed = totalSpeed/i;
    }

    // Length of ride
    currentMillis = millis()-startMillis;
    durationSeconds = currentMillis / 1000;
    durationMinutes = durationSeconds / 60;
    durationHours = durationMinutes / 60;
    currentMillis %= 1000;
    durationSeconds %= 60;
    durationMinutes %= 60;
    durationHours %= 24;
  }

  sprintf(durationFormatted, "%02d:%02d:%02d", durationHours, durationMinutes, durationSeconds);
  gpsLastSpeed = gpsSpeed;

  temp = tempReading();  
}

float tempReading() {
  // put your main code here, to run repeatedly:
  float ADCVal = analogRead(tempSensor);
  float tempC = ADCVal / 10;
  //Serial.println(tempC);

  temperatures[x] = tempC;
  x ++;
  if (x > 9) {
    x = 0;
  }

  float sum = temperatures[0] + temperatures[1] + temperatures[2] + temperatures[3] + temperatures[4] + temperatures[5] + temperatures[6] + temperatures[7] + temperatures[8] + temperatures[9];
  float avgTemp = ((sum/10)+7);

  return avgTemp;
}

void setRGBLED(int R, int G, int B) {
  ledcWrite(1, R);
  ledcWrite(2, G);
  ledcWrite(3, B);
}